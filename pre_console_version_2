
def reading_the_graph_as_adjacent_matrix():
    q_vertex, q_edge = [int(x) for x in input().split()] 
    graph = [[0]* q_vertex for i in range(q_vertex)]
    for edge in range(q_edge):
        v1, v2 = [int(x) for x in input().split()]
        graph[v1][v2] = 1
    return graph


def first_dfs(vertex, graph):
    used.add(vertex)
    for v in range(len(graph)):   
        if graph[vertex][v] == 1 and v not in used:   
            first_dfs(v, graph)
    list_vector.append(vertex)
    
def second_dfs(vertex, graph_t):
    visited.add(vertex)
    for v in list_vector:   
        if graph_t[vertex][v] == 1 and v not in visited:   
            second_dfs(v, graph_t)
    list_components.append(vertex)
    
          
		
def print_graph(A):
    for line in A:
        print(*line)
    print()			
                 
def reverse_graph(graph):
    graph_t = list(zip(*graph))
    return graph_t
				

			
#MAIN

#read the graph
graph = reading_the_graph_as_adjacent_matrix()

#call first depth-first search
used = set()
list_vector = []
for vertex in range(len(graph)):
   if vertex not in used:
      first_dfs(vertex, graph)              
list_vector.reverse()
#print(list)

#call second depth-first search
visited=set()
list_components = []
num = 0
graph_t = reverse_graph(graph)
for vertex in list_vector:
    if vertex not in visited:
        num += 1
        list_components = []
        second_dfs(vertex, graph_t)
        print(list_components)
#print(list_components)
print(num)
    

    






